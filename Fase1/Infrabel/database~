#lang racket
(require "locoADT"
         "trainStopADT"
         "switch"
         "rail-segmentADT"
         "signalADT"
         "label-unweighted-graph")
(provide new-database)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;HASH-TABLE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define make-table make-hash)
(define get-element hash-ref)
(define add-element hash-set!)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;HULPFUNCTIES---RAIL-WAIL-MODEL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (get-graph rwm) (vector-ref rwm 0))
(define (get-locos rwm) (vector-ref rwm 1))
(define (get-nodes rwm) (vector-ref rwm 2))
(define (get-switchs rwm) (vector-ref rwm 3))
(define (get-tracks rwm) (vector-ref rwm 4))
(define (get-detections rwm) (vector-ref rwm 5))
(define (get-signals rwm) (vector-ref rwm 6))

(define (new-node-index node index)
  (cons node index))
(define (give-node p)
  (car p))
(define (give-index p)
  (cdr p))


(define (new-rwm filename)  
  (define lines (map string-split (file->lines filename)))
  (define graph '())
  (define ls (make-table))
  (define ns '())
  (define amount-n 0)
  (define ss '())
  (define ts '())
  (define ds '())
  (define sigs '());;;Sigs stelt de lijst van signals voor en de aantal is evengroot als de aantal detections

  (define (add-nodes)
    (define table (make-table))
    (let loop ((node-index 0) (current ns))
      (when (not (null? current))
        (add-element table ((car current) 'get-id) (new-node-index (car current) node-index))
        ((graph 'label!) node-index ((car current) 'get-id))
        (loop (+ node-index 1) (cdr current))))
    (set! ns table))

  (define (add-tracks)
    ;een negatieve id wordt gemaakt voor elke track.
    ;Via zijn Id kan de track uit een tracktabel gehaald worden
    (define table (make-table))
    (let loop ((current ts) (id -1))
      (when (not (null? current))
        (let* ((t (car current))
               (node-index1 (cdr (get-element ns (t 'get-n1-id))))
               (node-index2 (cdr (get-element ns (t 'get-n2-id)))))
          ((graph 'add-edge!) node-index1 node-index2 id)
          (add-element table id t))
        (loop (cdr current) (- id 1))))
      (set! ts table))
  (define (add-detections)
    (define table-d (make-table))
    (define table-sigs (make-table))
    (let loop ((current-d ds) (current-s sigs))
      (when (not (null? current-d))
        (let*((d (car current-d))
              (s (car current-s))
              (t (d 'get-track))
              (node-index1 (cdr (get-element ns (t 'get-n1-id))))
              (node-index2 (cdr (get-element ns (t 'get-n2-id)))))
          ((graph 'add-edge!) node-index1 node-index2 (d 'get-id))
          (add-element table-d (d 'get-id) d)
          (add-element table-sigs (d 'get-id)  s))
        (loop (cdr current-d) (cdr current-s))))
    (set! ds table-d)
    (set! sigs table-sigs))
  (define (add-switchs)
    (define table (make-table))
    (let loop ((current ss))
      (when (not (null? current))
        (let* ((s (car current))
               (nm-i (cdr (get-element ns (s 'get-id-mn))))
               (n0-i (cdr (get-element ns (s'get-id-no))))
               (n1-i (cdr (get-element ns (s 'get-id-n1))))
               (n2-i (cdr (get-element ns (s 'get-id-n2)))))
          ((graph 'add-edge!) nm-i n1-i 's)
          ((graph 'add-edge!) n0-i nm-i 's)
          ((graph 'add-edge!) nm-i n2-i 's)
          (add-element table (s 'get-id-mn) s))
        (loop (cdr current))))
    (set! ss table))
        
  
  (for-each
   (lambda (l)
     (case (string->symbol (car l))
       [(L) (let* ([lid (string->symbol (list-ref l 1))]  
                   [n1 (string->symbol (list-ref l 2))]
                   [n2 (string->symbol (list-ref l 3))]
                   [res (new-loco lid n1 n2)])
              (add-element ls (res 'get-id) res)
              )]
       [(N) (let* ([id (string->symbol (list-ref l 1))] 
                   [x (string->number (list-ref l 2))]
                   [y (string->number (list-ref l 3))]
                   [res (new-node id x y)])
              (set! ns (cons res ns))
              (set! amount-n (+ amount-n 1)))]
       [(S) (let* ([nm (string->symbol (list-ref l 1))]  
                   [n0 (string->symbol (list-ref l 2))]
                   [n1 (string->symbol (list-ref l 3))]
                   [n2 (string->symbol (list-ref l 4))]
                   [res (new-switch nm n0 n1 n2)])
              (set! ss (cons res ss))
              )]
       [(T) (let* ([n1 (string->symbol (list-ref l 1))] 
                   [n2 (string->symbol (list-ref l 2))]
                   [res (new-track n1 n2)])
              (set! ts (cons res ts))
              )]
       [(D) (let* ([id (string->symbol (list-ref l 1))]    
                   [n1 (string->symbol (list-ref l 2))]
                   [n2 (string->symbol (list-ref l 3))]
                   [res (new-detection id n1 n2)]
                   [signal (new-signal id)])
              (set! ds (cons res ds))
              (set! sigs (cons signal sigs))
              )]))
   lines)
  (set! graph (new-unweighted-label-graph amount-n #f))
  
  
  ;;;Graph filling and tables filling step
  (add-nodes)
  (add-tracks)
  (add-detections)
  (add-switchs)
  (vector graph ls ns ss ts ds sigs))

(define (new-database file-name)
  (define model (new-rwm file-name))
  (define (get-loco id)
    (get-element (get-locos model) id))
  (define (get-node-index id)
    (give-index (get-element (get-nodes model) id)))
  (define (get-switch id)
    (get-element (get-switchs model) id))
  (define (get-track id)
    (get-element (get-tracks model) id))
  (define (get-detection id)
    (get-element (get-detections model) id))
  (define (get-signal id)
    (get-element (get-signals model) id))
  (define (dispatch msg)
    (cond((eq? msg 'get-graph) (get-graph model))
         ((eq? msg 'get-loco) get-loco)
         ((eq? msg 'get-node-index) get-node-index)
         ((eq? msg 'get-switch) get-switch)
         ((eq? msg 'get-track) get-track)
         ((eq? msg 'get-detection) get-detection)
         ((eq? msg 'get-signal) get-signal)
         (else (error "unknown msg -- Database"))))
  dispatch)

(define db (new-database "be_simple.txt"))